# GitCord

Introduction
---
GitCord는 하나의 방에 여러 유저들이 모여 토의하여 코드를 작성하고,
채팅과 음성 채팅을 통해 소통할 수 있는 웹 어플리케이션입니다.
코드 에디터와 화이트 보드 기능을 가지고 있으며,
코드 에디터로 간단한 코드를 작성하고 서로에게 실시간으로 공유하며
화이트 보드를 통해서 막힌 부분에 대해서 그림을 통해 보다 쉽게 설명할 수 있습니다.

Installation
---
Client
```
  git clone https://github.com/VanillaGitCord/GitCordFront.git
  npm install
  npm start
```

Server
```
  git clone https://github.com/VanillaGitCord/GitCordBack.git
  npm install
  npm run dev
```

Skill
---
Clinet
  - React를 사용하여 컴포넌트 기반 UI 구성
  - React router를 사용하여 routing 구현
  - Redux를 사용하여 Flux 아키텍쳐 기반으로 구성
  - lodash의 throlle 기능을 사용하여 이벤트 제어
  - socket.io-client를 사용하여 실시간 통신 기능 구현
  - simple-peer (webRtc)를 사용하여 캠, 음성 채팅 기능 구현
  - styled-components를 사용하여 컴포넌트 별 스타일 구성
  - codeMirror를 사용하여 코드 에디터 기능을 구현
  - HTML canvas를 사용하여 드로잉 보드 기능을 구현

Server
  - argon2를 사용하여 보안 강화
  - Node.js 프레임 워크 Express
  - json web token를 사용하여 토큰을 활용한 로그인 기능 구현
  - mongoDB Atlas
  - mongoose
  - socket.io를 사용하여 실시간 통신 기능 구현

Features
---
- 로컬 회원 가입 / 로그인 기능
- 구글 소셜 로그인
- 캠 기능 (방장만 가능)
- 마이크 기능 및 음소거 기능
  (모든 유저는 마이크 기능을 사용할 수 있으며, 방장은 마이크와 함께 캠을 끌 수 있습니다)
- 코드 에디터 기능 (자바스크립트 지원)
- 채팅 기능
- 코드 저장하기 기능
- 저장한 코드 불러오기 기능
- 채팅 기능
- 방 URL 클립보드 copy 기능
- 화이트 보드 기능 (color picker & All clear 내장)

Chanllenge
---
- 대부분의 기능이 socket을 이용한 실시간 데이터 송수신이 필요했습니다.
  socket.io와 Redux를 활용하여 데이터 flow를 관리하는 부분에서 문제들이 있었습니다.

  예를 들면 방장이 떠나게 될 경우, 기존 방 내에 있는 참여자들도 같이 channel 선택창으로
  이동한 후 다시 방장이 룸을 만들 경우 방이 만들어지고 바로 퇴장을 당하는 문제가 있었습니다.
  해당 문제는 socket.io의 로직이 비동기적으로 동작된다는 점이 문제가 됬고,
  redux의 dispatch 함수가 socket.io의 on emit 로직보다 더 빨리 실행되는게 문제의 원인이었습니다.

  문제 해결을 위해 방장이 나갈 경우 redux에서 상태값에 변화를 주면 해당 방에 그 상태 값을 통해
  퇴장 전 로딩 컴포넌트를 띄우고 해당 컴포넌트에서 useEffect를 통해 다시 redux의 상태값을
  초기 상태로 되돌리는 방식으로 flow를 형성하여 문제를 해결했습니다.

- socket.io와 재 렌더링 개선을 위한 과정
  기존 로직은 채팅, code editor, user List등 socket이 필요한 각각 컴포넌트에서
  송수신 로직을 각각 가지고 있었습니다. 리팩트 특성 상 state 값의 변화에 따라서 계속 재렌더링이 되며
  이 때마다 계속 socket과 관련된 로직들도 최적화가 안되어있는 상황에서 삭제 로직도 실행되는
  불필요한 행위가 지속되었습니다.

  그래서 on으로 받고 redux로 갱신하야 하는 socket 로직들을 한 곳에서 관리해야할 필요성을 느껴
  client에서 socket 대부분의 on로직을 한 곳에서 관리하고 이를 socket이 필요한 컴포넌트들의
  가장 상위 컴포넌트에 구독을 시키고, useEffect의 정리 함수를 활용하여 해당 컴포넌트를 벗어날 때
  한 번에 정리시켜 보다 깔끔하게 socket 로직을 관리하고, 코드를 개선할 수 있었습니다.

- 리액트의 재렌더링 기본 학습
  alertMessage들을 띄우는 컴포넌트는 배열로 된 message list를 돌면서
  message들을 출력하는 로직인데 이 과정에서 React의 unique 키 값을 uuid란 라이브러리를 통해
  해결하고자 했습니다. 이 과정에서 key에 `uuid()`란 코드를 작성하여 실행하였는데,
  배열 내에 있던 모든 message들이 업데이트 될 때마다 전부 재렌더링되는 현상을 겪었습니다.

  React에서는 해당 key의 값을 토대로 재랜더링 대상을 정하게 되는데 한 요소가 들어오게되면
  다시 message list를 돌고 이 때 `uuid()`를 토대로 전부 새로운 키 값들이 할당되면서
  전부 재 랜더링된다는 점을 기억하고 해당 키를 외부에서 미리 정하고 정해진 키를 기반으로
  랜더링을 하니 문제를 해결할 수 있었습니다.
  React의 기본적인 개념이었던만큼 이 경험을 통해 똑같은 실수를 반복하지 않겠다고 생각했습니다.

- 배포를 한 후 성능 저하에 대한 이슈 및 해결
  local에서 테스트를 했을 때 채팅, 코드 에디터 기능에 문제가 없었습니다.
  딜레이, 코드 에디터에서는 타이핑 시 폰트가 깨지는 현상 등 버그가 없었지만
  배포를 한 후에는 채팅, 코드 에디터의 딜레이 현상 그리고 코드 에디터 쪽에는 데이터 송수신의
  타이밍이 맞지 않아 작성한 내용들의 순서가 일정하지 않는 문제를 겪었습니다.

  해당 문제의 원인을 최적화의 문제로 생각했고, 최적화 진행을 위해 React.memo와 useCallback을
  사용하여 컴포넌트 최적화 및 컴포넌트 내 함수들의 최적화를 진행했으며,
  이 후 재배포 후 테스트를 해보니 채팅 쪽에 있던 딜레이 문제는 해결됬습니다.

  그러나 여전히 코드 에디터 쪽 문제는 남아있었고, 문제점을 확인한 결과 매 타이핑마다 계속
  socket 이벤트가 발생되고, socket에서 받은 데이터를 기반으로 다시 코드 에디터에 데이터를
  넘겨주는 방식으로 코드가 작성되었고
